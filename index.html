<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Video Explorer - Top AI Videos This Week</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --primary: #00ffcc;
            --primary-dark: #00ccaa;
            --secondary: #6366f1;
            --accent: #ff00ff;
            --dark: #0a0a0a;
            --darker: #000000;
            --light: #e0e0e0;
            --gray: #a0a0a0;
            --card-bg: rgba(10, 10, 20, 0.8);
            --glass: rgba(0, 255, 204, 0.05);
            --border: rgba(0, 255, 204, 0.2);
            --matrix-green: #00ff00;
            --matrix-blue: #00ccff;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Courier New', monospace;
        }

        body {
            background: #000;
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
            position: relative;
        }

        /* Matrix Background */
        #matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            opacity: 0.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
            padding: 30px;
            background: linear-gradient(135deg, rgba(0, 20, 40, 0.8), rgba(0, 10, 30, 0.8));
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.3);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: linear-gradient(45deg, var(--primary), var(--secondary), var(--accent), var(--primary));
            border-radius: 20px;
            opacity: 0.5;
            z-index: -1;
            animation: borderRotate 8s linear infinite;
        }

        @keyframes borderRotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        h1 {
            font-size: 3.5rem;
            margin-bottom: 15px;
            background: linear-gradient(90deg, var(--primary), var(--matrix-blue), var(--accent));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
            font-weight: bold;
            letter-spacing: 2px;
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--gray);
            max-width: 700px;
            margin: 0 auto;
            line-height: 1.6;
            text-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .control-btn {
            background: linear-gradient(135deg, rgba(0, 30, 60, 0.8), rgba(0, 20, 40, 0.8));
            border: 1px solid var(--border);
            color: var(--light);
            padding: 12px 25px;
            border-radius: 50px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        .control-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 204, 0.4), transparent);
            transition: left 0.5s;
        }

        .control-btn:hover::before {
            left: 100%;
        }

        .control-btn:hover {
            background: linear-gradient(135deg, rgba(0, 50, 100, 0.9), rgba(0, 30, 60, 0.9));
            transform: translateY(-3px);
            box-shadow: 0 10px 20px rgba(0, 255, 204, 0.3);
            border-color: var(--primary);
        }

        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
            gap: 25px;
            margin-bottom: 40px;
        }

        .video-card {
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.9), rgba(5, 5, 20, 0.9));
            border-radius: 16px;
            overflow: hidden;
            transition: all 0.4s ease;
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            height: 100%;
            position: relative;
        }

        .video-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .video-card:hover::before {
            opacity: 1;
        }

        .video-card:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 35px rgba(0, 255, 204, 0.2);
            border-color: var(--primary);
        }

        .thumbnail-container {
            position: relative;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            overflow: hidden;
            background: #000;
        }

        .thumbnail {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transition: opacity 0.5s ease;
        }

        .video-preview {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .video-card:hover .thumbnail {
            opacity: 0;
        }

        .video-card:hover .video-preview {
            opacity: 1;
        }

        .play-btn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 70px;
            height: 70px;
            background: rgba(0, 255, 204, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            border: 2px solid var(--primary);
            z-index: 10;
        }

        .play-btn:hover {
            background: rgba(0, 255, 204, 0.4);
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.6);
        }

        .play-btn i {
            color: var(--primary);
            font-size: 24px;
            margin-left: 5px;
        }

        .video-info {
            padding: 20px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }

        .video-title {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 10px;
            line-height: 1.4;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            color: var(--light);
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.3);
        }

        .video-meta {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            color: var(--gray);
            font-size: 0.9rem;
        }

        .video-stats {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            color: var(--gray);
            font-size: 0.9rem;
        }

        .video-stats span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .video-stats i {
            color: var(--primary);
        }

        .channel-info {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: auto;
        }

        .channel-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            object-fit: cover;
            border: 2px solid var(--border);
        }

        .channel-name {
            font-weight: 500;
            color: var(--light);
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
        }

        .modal-content {
            position: relative;
            width: 90%;
            max-width: 900px;
            background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(5, 5, 20, 0.95));
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
            border: 1px solid var(--border);
        }

        .modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 20, 40, 0.5);
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary);
        }

        .close-btn {
            background: none;
            border: none;
            color: var(--gray);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: var(--accent);
        }

        .video-player {
            position: relative;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            background: #000;
        }

        .video-player iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .loading {
            text-align: center;
            padding: 60px 20px;
            font-size: 1.2rem;
            color: var(--primary);
        }

        .loading i {
            font-size: 3rem;
            margin-bottom: 20px;
            animation: spin 2s infinite linear;
            color: var(--primary);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .footer {
            text-align: center;
            padding: 30px;
            color: var(--gray);
            font-size: 0.9rem;
            border-top: 1px solid var(--border);
            margin-top: 40px;
            background: rgba(0, 20, 40, 0.3);
            border-radius: 16px;
            backdrop-filter: blur(5px);
        }

        .footer a {
            color: var(--primary);
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 2.5rem;
            }
            
            .video-grid {
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 20px;
            }
            
            .modal-content {
                width: 95%;
            }
        }
    </style>
</head>
<body>
    <canvas id="matrix-bg"></canvas>
    
    <div class="container">
        <header>
            <h1>AI VIDEO EXPLORER</h1>
            <p class="subtitle">[ ACCESSING NEURAL NETWORK: TOP 10 AI VIDEOS FROM PAST WEEK ]</p>
        </header>

        <div class="controls">
            <button class="control-btn" id="refreshBtn">
                <i class="fas fa-sync-alt"></i> REFRESH DATA
            </button>
            <button class="control-btn" id="aboutBtn">
                <i class="fas fa-info-circle"></i> SYSTEM INFO
            </button>
            <button class="control-btn" id="diagnosticsBtn">
                <i class="fas fa-heartbeat"></i> DIAGNOSTICS
            </button>
        </div>

        <div id="loadingIndicator" class="loading">
            <i class="fas fa-cog"></i>
            <p>[ INITIALIZING QUANTUM PROCESSOR... ]</p>
        </div>

        <div id="videoGrid" class="video-grid" style="display: none;">
            <!-- Videos will be dynamically loaded here -->
        </div>

        <div id="videoModal" class="modal">
            <div class="modal-content">
                <div class="modal-header">
                    <h3 class="modal-title" id="modalTitle">[ VIDEO PLAYER ]</h3>
                    <button class="close-btn" id="closeModal">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div class="video-player" id="videoPlayer">
                    <!-- YouTube player will be embedded here -->
                </div>
            </div>
        </div>

        <footer class="footer">
            <p>[ AI VIDEO EXPLORER v2.0 • DATA STREAM: YOUTUBE API • 
            <a href="https://developers.google.com/youtube/v3" target="_blank">NEURAL LINK</a>
            ]</p>
        </footer>
    </div>

    <!-- Self-Healing Services -->
    <script src="self-healing.js"></script>
    <script src="image-healing.js"></script>

    <script>
        // Initialize Self-Healing Service
        const selfHealing = new SelfHealingService({
            retryAttempts: 3,
            retryDelay: 1000,
            maxRetryDelay: 15000,
            performanceThreshold: 8000,
            healthCheckInterval: 45000,
            cacheExpiryTime: 30 * 60 * 1000 // 30 minutes
        });

        // Initialize Image Self-Healing Service
        const imageHealing = new ImageSelfHealingService({
            maxRetries: 3,
            retryDelay: 500,
            healthCheckInterval: 5 * 60 * 1000 // 5 minutes
        });

        // Register Service Worker for offline capabilities
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', async () => {
                try {
                    const registration = await navigator.serviceWorker.register('/sw.js');
                    console.log('✅ Service Worker registered successfully:', registration);
                    
                    // Listen for service worker updates
                    registration.addEventListener('updatefound', () => {
                        console.log('🔄 Service Worker update found');
                        const newWorker = registration.installing;
                        newWorker.addEventListener('statechange', () => {
                            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                                console.log('🆕 New Service Worker available - consider updating');
                                showSystemNotification('Application update available', 'info');
                            }
                        });
                    });
                    
                } catch (error) {
                    console.error('❌ Service Worker registration failed:', error);
                }
            });
        } else {
            console.warn('⚠️ Service Worker not supported in this browser');
        }

        // Listen for self-healing events
        window.addEventListener('self-healing:network-recovered', () => {
            console.log('🌐 Network recovered - refreshing data');
            loadVideos();
        });

        window.addEventListener('self-healing:health-update', (event) => {
            console.log('🏥 Health status update:', event.detail);
            updateSystemStatus(event.detail);
        });

        window.addEventListener('self-healing:cleanup-performed', () => {
            console.log('🧹 Memory cleanup performed');
        });

        window.addEventListener('self-healing:recovery-attempted', () => {
            console.log('🔄 System recovery attempted - reloading data');
            loadVideos();
        });

        window.addEventListener('self-healing:state-recovered', (event) => {
            console.log('📦 Application state recovered:', event.detail);
            showSystemNotification('Application state restored from previous session', 'info');
        });

        window.addEventListener('self-healing:circuit-breaker-opened', () => {
            console.log('🔒 Circuit breaker opened - switching to fallback mode');
            showSystemNotification('API protection activated - using cached data', 'warning');
        });

        window.addEventListener('self-healing:circuit-breaker-closed', () => {
            console.log('✅ Circuit breaker closed - API services restored');
            showSystemNotification('API services restored - live data available', 'success');
            loadVideos();
        });

        // Matrix Rain Effect
        const canvas = document.getElementById('matrix-bg');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}01";
        const matrixArray = matrix.split("");

        const fontSize = 10;
        const columns = canvas.width / fontSize;

        const drops = [];
        for(let x = 0; x < columns; x++) {
            drops[x] = 1;
        }

        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#00ffcc';
            ctx.font = fontSize + 'px monospace';

            for(let i = 0; i < drops.length; i++) {
                const text = matrixArray[Math.floor(Math.random() * matrixArray.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }

        window.matrixInterval = setInterval(drawMatrix, 35);

        // Resize canvas when window is resized
        window.addEventListener('resize', function() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // YouTube API configuration - loaded from config.json with self-healing validation
        let API_KEY = 'YOUR_YOUTUBE_API_KEY'; // fallback value
        let APP_CONFIG = null;
        const API_URL = 'https://www.googleapis.com/youtube/v3/';
        
        // Enhanced configuration loading with self-healing
        async function loadConfig() {
            try {
                console.log('📋 Loading configuration with self-healing validation...');
                const response = await selfHealing.resilientApiCall('config.json');
                
                // Use self-healing config validation
                const { config: validatedConfig, repairs } = selfHealing.validateAndRepairConfig(response);
                
                if (repairs.length > 0) {
                    console.warn('🔧 Configuration was automatically repaired:', repairs);
                    // Optionally show user notification about repairs
                    showSystemNotification('Configuration auto-repaired', 'info');
                }
                
                API_KEY = validatedConfig.API_KEY || 'YOUR_YOUTUBE_API_KEY';
                APP_CONFIG = validatedConfig;
                
                // Apply UI settings
                if (validatedConfig.ui_settings) {
                    applyUISettings(validatedConfig.ui_settings);
                }
                
                console.log('✅ Configuration loaded and validated');
                return validatedConfig;
            } catch (error) {
                console.warn('⚠️ Could not load config.json, using self-healed defaults:', error);
                
                // Use self-healing to generate safe defaults
                const defaultConfig = {
                    API_KEY: 'YOUR_YOUTUBE_API_KEY',
                    app_settings: {
                        max_results: 50,
                        videos_to_display: 10,
                        cache_duration_minutes: 30
                    },
                    ui_settings: {
                        matrix_effect_speed: 35,
                        autoplay_preview: true
                    }
                };
                
                const { config: healedConfig } = selfHealing.validateAndRepairConfig(defaultConfig);
                API_KEY = healedConfig.API_KEY;
                APP_CONFIG = healedConfig;
                
                showSystemNotification('Using default configuration', 'warning');
                return healedConfig;
            }
        }
        
        // Apply UI settings with error handling
        function applyUISettings(uiSettings) {
            try {
                // Update matrix effect speed
                if (uiSettings.matrix_effect_speed && typeof uiSettings.matrix_effect_speed === 'number') {
                    // Clear existing interval and create new one with updated speed
                    clearInterval(window.matrixInterval);
                    window.matrixInterval = setInterval(drawMatrix, uiSettings.matrix_effect_speed);
                }
            } catch (error) {
                console.warn('⚠️ Error applying UI settings:', error);
            }
        }
        
        // DOM elements
        const videoGrid = document.getElementById('videoGrid');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const videoModal = document.getElementById('videoModal');
        const modalTitle = document.getElementById('modalTitle');
        const videoPlayer = document.getElementById('videoPlayer');
        const closeModal = document.getElementById('closeModal');
        const refreshBtn = document.getElementById('refreshBtn');
        const aboutBtn = document.getElementById('aboutBtn');
        const diagnosticsBtn = document.getElementById('diagnosticsBtn');
        
        // Sample video data (in case API key is not provided)
        const sampleVideos = [
            {
                id: 'video1',
                title: 'The Future of Artificial Intelligence: What to Expect in the Next Decade',
                channel: 'TechVision',
                channelId: 'UC123456789',
                thumbnail: 'https://picsum.photos/seed/ai1/640/360.jpg',
                views: '2.4M',
                likes: '120K',
                publishedAt: '2023-05-15'
            },
            {
                id: 'video2',
                title: 'How AI is Revolutionizing Healthcare: Breakthrough Technologies',
                channel: 'HealthTech Insights',
                channelId: 'UC987654321',
                thumbnail: 'https://picsum.photos/seed/ai2/640/360.jpg',
                views: '1.8M',
                likes: '95K',
                publishedAt: '2023-05-14'
            },
            {
                id: 'video3',
                title: 'Building Your First AI Model: A Beginner\'s Guide',
                channel: 'AI Academy',
                channelId: 'UC456789123',
                thumbnail: 'https://picsum.photos/seed/ai3/640/360.jpg',
                views: '1.5M',
                likes: '85K',
                publishedAt: '2023-05-13'
            },
            {
                id: 'video4',
                title: 'The Ethics of Artificial Intelligence: Challenges and Solutions',
                channel: 'Tech Ethics',
                channelId: 'UC789123456',
                thumbnail: 'https://picsum.photos/seed/ai4/640/360.jpg',
                views: '1.2M',
                likes: '78K',
                publishedAt: '2023-05-12'
            },
            {
                id: 'video5',
                title: 'AI vs Human Intelligence: The Ultimate Showdown',
                channel: 'Future Tech',
                channelId: 'UC321654987',
                thumbnail: 'https://picsum.photos/seed/ai5/640/360.jpg',
                views: '1.1M',
                likes: '65K',
                publishedAt: '2023-05-11'
            },
            {
                id: 'video6',
                title: 'How Deep Learning Works: Explained Simply',
                channel: 'AI Simplified',
                channelId: 'UC654987321',
                thumbnail: 'https://picsum.photos/seed/ai6/640/360.jpg',
                views: '980K',
                likes: '52K',
                publishedAt: '2023-05-10'
            },
            {
                id: 'video7',
                title: 'The Impact of AI on Jobs: What You Need to Know',
                channel: 'Economy Today',
                channelId: 'UC147258369',
                thumbnail: 'https://picsum.photos/seed/ai7/640/360.jpg',
                views: '850K',
                likes: '48K',
                publishedAt: '2023-05-09'
            },
            {
                id: 'video8',
                title: 'GPT-5: The Next Generation of Language Models',
                channel: 'AI Research Hub',
                channelId: 'UC369147258',
                thumbnail: 'https://picsum.photos/seed/ai8/640/360.jpg',
                views: '780K',
                likes: '45K',
                publishedAt: '2023-05-08'
            },
            {
                id: 'video9',
                title: 'AI in Autonomous Vehicles: How Self-Driving Cars Work',
                channel: 'Auto Tech',
                channelId: 'UC258369147',
                thumbnail: 'https://picsum.photos/seed/ai9/640/360.jpg',
                views: '720K',
                likes: '42K',
                publishedAt: '2023-05-07'
            },
            {
                id: 'video10',
                title: 'The History of Artificial Intelligence: From Turing to Today',
                channel: 'Tech History',
                channelId: 'UC147258963',
                thumbnail: 'https://picsum.photos/seed/ai10/640/360.jpg',
                views: '650K',
                likes: '38K',
                publishedAt: '2023-05-06'
            }
        ];
        
        // Initialize the app
        async function init() {
            // Load configuration first
            await loadConfig();
            
            // Then load videos
            loadVideos();
            
            // Event listeners
            closeModal.addEventListener('click', closeVideoModal);
            refreshBtn.addEventListener('click', loadVideos);
            aboutBtn.addEventListener('click', showAbout);
            diagnosticsBtn.addEventListener('click', showDiagnostics);
            
            // Close modal when clicking outside
            window.addEventListener('click', function(event) {
                if (event.target === videoModal) {
                    closeVideoModal();
                }
            });
        }
        
        // Enhanced video loading with self-healing capabilities
        function loadVideos() {
            loadingIndicator.style.display = 'block';
            videoGrid.style.display = 'none';
            
            console.log('📺 Loading videos with self-healing...');
            
            // Update loading message based on network status
            const healthStatus = selfHealing.getHealthStatus();
            updateLoadingMessage(healthStatus);
            
            // If API key is not provided, use sample data
            if (API_KEY === 'YOUR_YOUTUBE_API_KEY') {
                console.log('🎭 Using sample data (no valid API key)');
                setTimeout(() => {
                    displayVideos(sampleVideos);
                    showSystemNotification('Demo mode active - using sample data', 'info');
                }, 1500);
            } else {
                console.log('🚀 Attempting to fetch from YouTube API with self-healing...');
                // Enhanced fetch with self-healing
                fetchTopAIVideosWithHealing()
                    .then(videos => {
                        console.log('✅ Successfully fetched', videos.length, 'videos with self-healing');
                        displayVideos(videos);
                        showSystemNotification('Data loaded successfully', 'success');
                    })
                    .catch(error => {
                        console.error('❌ Error fetching videos even with self-healing:', error);
                        console.log('🎭 Falling back to sample data');
                        displayVideos(sampleVideos);
                        showSystemNotification('Using fallback data due to API issues', 'warning');
                    });
            }
        }
        
        // Update loading message based on system health
        function updateLoadingMessage(healthStatus) {
            const loadingText = document.querySelector('#loadingIndicator p');
            if (loadingText) {
                if (healthStatus.status.network === 'offline') {
                    loadingText.textContent = '[ NETWORK OFFLINE - LOADING CACHED DATA... ]';
                } else if (healthStatus.status.api === 'unhealthy') {
                    loadingText.textContent = '[ API ISSUES DETECTED - ATTEMPTING RECOVERY... ]';
                } else if (healthStatus.status.performance === 'degraded') {
                    loadingText.textContent = '[ PERFORMANCE OPTIMIZATION IN PROGRESS... ]';
                } else {
                    loadingText.textContent = '[ INITIALIZING QUANTUM PROCESSOR... ]';
                }
            }
        }
        
        // Enhanced API fetching with self-healing
        async function fetchTopAIVideosWithHealing() {
            try {
                // Calculate date one week ago
                const oneWeekAgo = new Date();
                oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);
                const publishedAfter = oneWeekAgo.toISOString();
                
                console.log('🔍 Searching for videos with self-healing protection...');
                
                // Use self-healing API call for search
                const searchUrl = `${API_URL}search?part=snippet&q=Artificial%20Intelligence&type=video&order=viewCount&publishedAfter=${publishedAfter}&maxResults=${APP_CONFIG?.app_settings?.max_results || 50}&key=${API_KEY}`;
                
                const searchData = await selfHealing.resilientApiCall(searchUrl);
                
                // Handle API errors or empty results
                if (searchData.error && searchData.error.type === 'fallback') {
                    console.log('🎭 API unavailable - using fallback mode');
                    throw new Error('API unavailable, using fallback data');
                }
                
                if (!searchData.items || searchData.items.length === 0) {
                    console.log('📭 No videos found in search results');
                    throw new Error('No videos found');
                }
                
                // Extract video IDs
                const videoIds = searchData.items.map(item => item.id.videoId || item.id).filter(Boolean).join(',');
                console.log('🎥 Found video IDs:', videoIds);
                
                if (!videoIds) {
                    throw new Error('No valid video IDs found');
                }
                
                // Get video details with self-healing
                const videosUrl = `${API_URL}videos?part=snippet,statistics&id=${videoIds}&key=${API_KEY}`;
                const videosData = await selfHealing.resilientApiCall(videosUrl);
                
                if (videosData.error && videosData.error.type === 'fallback') {
                    console.log('🎭 Video details API unavailable - using fallback');
                    throw new Error('Video details API unavailable');
                }
                
                if (!videosData.items) {
                    throw new Error('No video details received');
                }
                
                // Sort by view count and limit results
                const maxResults = APP_CONFIG?.app_settings?.videos_to_display || 10;
                const sortedVideos = videosData.items
                    .filter(video => video && video.id && video.snippet)
                    .sort((a, b) => {
                        const aViews = parseInt(b.statistics?.viewCount || 0);
                        const bViews = parseInt(a.statistics?.viewCount || 0);
                        return bViews - aViews;
                    })
                    .slice(0, maxResults);
                
                // Format data with additional validation
                return sortedVideos.map(video => ({
                    id: video.id,
                    title: selfHealing.sanitizeString(video.snippet.title),
                    channel: selfHealing.sanitizeString(video.snippet.channelTitle),
                    channelId: video.snippet.channelId,
                    thumbnail: video.snippet.thumbnails?.high?.url || video.snippet.thumbnails?.medium?.url || video.snippet.thumbnails?.default?.url,
                    views: formatViewCount(video.statistics?.viewCount || 0),
                    likes: formatViewCount(video.statistics?.likeCount || 0),
                    publishedAt: video.snippet.publishedAt
                }));
            } catch (error) {
                console.error('🚨 Error in fetchTopAIVideosWithHealing:', error);
                throw error;
            }
        }
        
        // Format view count (e.g., 1500000 -> 1.5M)
        function formatViewCount(count) {
            if (count >= 1000000) {
                return (count / 1000000).toFixed(1) + 'M';
            } else if (count >= 1000) {
                return (count / 1000).toFixed(1) + 'K';
            } else {
                return count.toString();
            }
        }
        
        // System notification functionality
        function showSystemNotification(message, type = 'info') {
            // Create or get notification container
            let notificationContainer = document.getElementById('notification-container');
            if (!notificationContainer) {
                notificationContainer = document.createElement('div');
                notificationContainer.id = 'notification-container';
                notificationContainer.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    z-index: 10000;
                    max-width: 400px;
                `;
                document.body.appendChild(notificationContainer);
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                background: linear-gradient(135deg, rgba(0, 20, 40, 0.95), rgba(0, 10, 30, 0.95));
                border: 1px solid var(--border);
                border-radius: 8px;
                padding: 12px 16px;
                margin-bottom: 10px;
                color: var(--light);
                font-family: 'Courier New', monospace;
                font-size: 0.9rem;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                backdrop-filter: blur(10px);
                opacity: 0;
                transform: translateX(100%);
                transition: all 0.3s ease;
            `;
            
            // Set type-specific styling
            const typeColors = {
                success: '#00ffcc',
                warning: '#ffaa00',
                error: '#ff3366',
                info: '#00aaff'
            };
            
            const color = typeColors[type] || typeColors.info;
            notification.style.borderColor = color;
            
            // Add icon and message
            const icons = {
                success: '✅',
                warning: '⚠️',
                error: '❌',
                info: 'ℹ️'
            };
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="color: ${color};">${icons[type] || icons.info}</span>
                    <span>${message}</span>
                </div>
            `;
            
            notificationContainer.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // Auto remove after delay
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 4000);
        }
        
        // Update system status display
        function updateSystemStatus(healthData) {
            // Add status indicators to the header if they don't exist
            let statusContainer = document.getElementById('system-status');
            if (!statusContainer) {
                statusContainer = document.createElement('div');
                statusContainer.id = 'system-status';
                statusContainer.style.cssText = `
                    position: absolute;
                    top: 15px;
                    right: 15px;
                    display: flex;
                    gap: 8px;
                    align-items: center;
                `;
                
                const header = document.querySelector('header');
                header.appendChild(statusContainer);
            }
            
            // Create status indicators
            const indicators = [
                { key: 'network', icon: '🌐', title: 'Network Status' },
                { key: 'api', icon: '🔌', title: 'API Status' },
                { key: 'performance', icon: '⚡', title: 'Performance' },
                { key: 'circuitBreaker', icon: '🛡️', title: 'Circuit Breaker' },
                { key: 'storage', icon: '💾', title: 'Storage Recovery' }
            ];
            
            statusContainer.innerHTML = indicators.map(indicator => {
                const status = healthData.status[indicator.key];
                const color = getStatusColor(status);
                
                return `
                    <div title="${indicator.title}: ${status}" style="
                        color: ${color};
                        font-size: 1.2rem;
                        cursor: help;
                        filter: drop-shadow(0 0 3px ${color});
                    ">${indicator.icon}</div>
                `;
            }).join('');
        }
        
        // Get color based on status
        function getStatusColor(status) {
            switch (status) {
                case 'healthy': case 'online': case 'closed': return '#00ffcc';
                case 'degraded': case 'unhealthy': case 'half-open': return '#ffaa00';
                case 'offline': case 'critical': case 'open': case 'unavailable': return '#ff3366';
                default: return '#888888';
            }
        }
        // Enhanced video display with self-healing memory management
        function displayVideos(videos) {
            try {
                // Clear existing content with memory cleanup
                clearVideoGrid();
                
                if (!videos || !Array.isArray(videos) || videos.length === 0) {
                    showEmptyState();
                    return;
                }
                
                console.log('📺 Displaying', videos.length, 'videos with enhanced error handling');
                
                videos.forEach((video, index) => {
                    try {
                        if (!video || !video.id) {
                            console.warn(`⚠️ Invalid video data at index ${index}:`, video);
                            return;
                        }
                        
                        const videoCard = document.createElement('div');
                        videoCard.className = 'video-card';
                        videoCard.setAttribute('data-video-id', video.id);
                        
                        // Format date safely
                        let formattedDate = 'Unknown date';
                        try {
                            if (video.publishedAt) {
                                const publishDate = new Date(video.publishedAt);
                                if (!isNaN(publishDate.getTime())) {
                                    formattedDate = publishDate.toLocaleDateString('en-US', {
                                        month: 'short',
                                        day: 'numeric',
                                        year: 'numeric'
                                    });
                                }
                            }
                        } catch (dateError) {
                            console.warn('⚠️ Error formatting date for video:', video.id, dateError);
                        }
                        
                        // Create safe thumbnail URL with self-healing
                        const thumbnailUrl = video.thumbnail || `https://picsum.photos/seed/${video.id}/640/360.jpg`;
                        const channelAvatarUrl = `https://picsum.photos/seed/${video.channelId || video.id}/100/100.jpg`;
                        
                        videoCard.innerHTML = `
                            <div class="thumbnail-container">
                                <img data-src="${thumbnailUrl}" data-image-type="thumbnail" alt="${video.title || 'Video thumbnail'}" class="thumbnail"
                                     src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQwIiBoZWlnaHQ9IjM2MCIgdmlld0JveD0iMCAwIDY0MCAzNjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI2NDAiIGhlaWdodD0iMzYwIiBmaWxsPSIjMGEwYTBhIi8+Cjx0ZXh0IHg9IjMyMCIgeT0iMTgwIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmaWxsPSIjMDBmZmNjIiBmb250LWZhbWlseT0iQ291cmllciBOZXciIGZvbnQtc2l6ZT0iMjQiPkxvYWRpbmcuLi48L3RleHQ+Cjwvc3ZnPgo=">
                                <video class="video-preview" muted loop preload="none">
                                    <source src="https://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4" type="video/mp4">
                                    Your browser does not support the video tag.
                                </video>
                                <div class="play-btn" data-video-id="${video.id}">
                                    <i class="fas fa-play"></i>
                                </div>
                            </div>
                            <div class="video-info">
                                <h3 class="video-title">${video.title || 'Untitled Video'}</h3>
                                <div class="video-meta">
                                    <span>${formattedDate}</span>
                                </div>
                                <div class="video-stats">
                                    <span><i class="fas fa-eye"></i> ${video.views || '0'} views</span>
                                    <span><i class="fas fa-thumbs-up"></i> ${video.likes || '0'}</span>
                                </div>
                                <div class="channel-info">
                                    <img data-src="${channelAvatarUrl}" data-image-type="avatar" alt="${video.channel || 'Channel'}" class="channel-avatar"
                                         src="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgdmlld0JveD0iMCAwIDEwMCAxMDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxjaXJjbGUgY3g9IjUwIiBjeT0iNTAiIHI9IjUwIiBmaWxsPSIjMGEwYTBhIi8+Cjx0ZXh0IHg9IjUwIiB5PSI1NSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZmlsbD0iIzAwZmZjYyIgZm9udC1mYW1pbHk9IkNvdXJpZXIgTmV3IiBmb250LXNpemU9IjEyIj5BSTwvdGV4dD4KPC9zdmc+Cg==">
                                    <span class="channel-name">${video.channel || 'Unknown Channel'}</span>
                                </div>
                            </div>
                        `;
                        
                        videoGrid.appendChild(videoCard);
                        
                        // Enhanced hover events with error handling
                        setupVideoCardEvents(videoCard, video);
                        
                    } catch (cardError) {
                        console.error(`❌ Error creating video card for index ${index}:`, cardError);
                        // Continue with other videos
                    }
                });
                
                loadingIndicator.style.display = 'none';
                videoGrid.style.display = 'grid';
                
                // Trigger image self-healing for all images
                setTimeout(() => {
                    imageHealing.healAllImages();
                }, 100);
                
                console.log('✅ Video display completed successfully');
                
            } catch (error) {
                console.error('❌ Critical error in displayVideos:', error);
                showErrorState();
            }
        }
        
        // Setup video card event listeners with error handling
        function setupVideoCardEvents(videoCard, video) {
            try {
                const videoPreview = videoCard.querySelector('.video-preview');
                const playBtn = videoCard.querySelector('.play-btn');
                
                if (videoPreview) {
                    // Enhanced hover events with self-healing
                    const mouseEnterHandler = () => {
                        try {
                            if (APP_CONFIG?.ui_settings?.autoplay_preview !== false && navigator.onLine) {
                                videoPreview.play().catch(e => {
                                    console.warn('⚠️ Video preview play failed:', e.message);
                                });
                            }
                        } catch (error) {
                            console.warn('⚠️ Error in video preview mouseenter:', error);
                        }
                    };
                    
                    const mouseLeaveHandler = () => {
                        try {
                            videoPreview.pause();
                            videoPreview.currentTime = 0;
                        } catch (error) {
                            console.warn('⚠️ Error in video preview mouseleave:', error);
                        }
                    };
                    
                    videoCard.addEventListener('mouseenter', mouseEnterHandler);
                    videoCard.addEventListener('mouseleave', mouseLeaveHandler);
                    
                    // Store event handlers for cleanup
                    videoCard._eventHandlers = { mouseEnterHandler, mouseLeaveHandler };
                }
                
                if (playBtn) {
                    const clickHandler = (event) => {
                        event.stopPropagation();
                        try {
                            openVideoModal(video);
                        } catch (error) {
                            console.error('❌ Error opening video modal:', error);
                            showSystemNotification(`Error playing video: ${video.title}`, 'error');
                        }
                    };
                    
                    playBtn.addEventListener('click', clickHandler);
                    playBtn._clickHandler = clickHandler;
                }
                
            } catch (error) {
                console.error('❌ Error setting up video card events:', error);
            }
        }
        
        // Clear video grid with proper cleanup
        function clearVideoGrid() {
            try {
                // Clean up existing video elements to prevent memory leaks
                const existingCards = videoGrid.querySelectorAll('.video-card');
                existingCards.forEach(card => {
                    // Pause and cleanup video previews
                    const preview = card.querySelector('.video-preview');
                    if (preview) {
                        preview.pause();
                        preview.src = '';
                        preview.load();
                    }
                    
                    // Remove event listeners if they exist
                    if (card._eventHandlers) {
                        card.removeEventListener('mouseenter', card._eventHandlers.mouseEnterHandler);
                        card.removeEventListener('mouseleave', card._eventHandlers.mouseLeaveHandler);
                    }
                    
                    const playBtn = card.querySelector('.play-btn');
                    if (playBtn && playBtn._clickHandler) {
                        playBtn.removeEventListener('click', playBtn._clickHandler);
                    }
                });
                
                videoGrid.innerHTML = '';
            } catch (error) {
                console.error('❌ Error clearing video grid:', error);
                // Force clear if cleanup fails
                videoGrid.innerHTML = '';
            }
        }
        
        // Show empty state
        function showEmptyState() {
            videoGrid.innerHTML = `
                <div style="
                    grid-column: 1 / -1;
                    text-align: center;
                    padding: 60px 20px;
                    color: var(--gray);
                ">
                    <i class="fas fa-video" style="font-size: 3rem; margin-bottom: 20px; color: var(--primary);"></i>
                    <h3>No Videos Found</h3>
                    <p>Unable to load video content at this time.</p>
                    <button class="control-btn" onclick="loadVideos()" style="margin-top: 20px;">
                        <i class="fas fa-retry"></i> Try Again
                    </button>
                </div>
            `;
            
            loadingIndicator.style.display = 'none';
            videoGrid.style.display = 'grid';
        }
        
        // Show error state
        function showErrorState() {
            videoGrid.innerHTML = `
                <div style="
                    grid-column: 1 / -1;
                    text-align: center;
                    padding: 60px 20px;
                    color: var(--accent);
                ">
                    <i class="fas fa-exclamation-triangle" style="font-size: 3rem; margin-bottom: 20px; color: var(--accent);"></i>
                    <h3>System Error</h3>
                    <p>A critical error occurred while loading content.</p>
                    <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
                        <button class="control-btn" onclick="loadVideos()">
                            <i class="fas fa-retry"></i> Retry
                        </button>
                        <button class="control-btn" onclick="selfHealing.attemptRecovery()">
                            <i class="fas fa-wrench"></i> Self-Heal
                        </button>
                    </div>
                </div>
            `;
            
            loadingIndicator.style.display = 'none';
            videoGrid.style.display = 'grid';
        }
        
        // Open video modal and embed player
        function openVideoModal(video) {
            modalTitle.textContent = `[ ${video.title} ]`;
            videoPlayer.innerHTML = `
                <iframe 
                    src="https://www.youtube.com/embed/${video.id}?autoplay=1" 
                    frameborder="0" 
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                    allowfullscreen>
                </iframe>
            `;
            videoModal.style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }
        
        // Close video modal
        function closeVideoModal() {
            videoModal.style.display = 'none';
            videoPlayer.innerHTML = '';
            document.body.style.overflow = 'auto';
        }
        
        // Enhanced about information with self-healing diagnostics
        function showAbout() {
            const diagnostics = selfHealing.getDiagnostics();
            const healthStatus = selfHealing.getHealthStatus();
            
            // Create modal-style about dialog instead of basic alert
            const aboutModal = document.createElement('div');
            aboutModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                backdrop-filter: blur(5px);
            `;
            
            aboutModal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(5, 5, 20, 0.95));
                    border: 1px solid var(--border);
                    border-radius: 16px;
                    padding: 30px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    color: var(--light);
                    font-family: 'Courier New', monospace;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
                ">
                    <div style="text-align: center; margin-bottom: 25px;">
                        <h2 style="color: var(--primary); margin-bottom: 10px;">[ SYSTEM INFORMATION ]</h2>
                        <div style="color: var(--gray); font-size: 0.9rem;">AI VIDEO EXPLORER v3.1 • ENHANCED SELF-HEALING ENABLED</div>
                    </div>
                    
                    <div style="display: grid; gap: 20px;">
                        <div>
                            <h3 style="color: var(--primary); margin-bottom: 10px;">🏥 SELF-HEALING STATUS</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
                                <div>Network: <span style="color: ${getStatusColor(healthStatus.status.network)}">${healthStatus.status.network?.toUpperCase()}</span></div>
                                <div>API: <span style="color: ${getStatusColor(healthStatus.status.api)}">${healthStatus.status.api?.toUpperCase()}</span></div>
                                <div>Config: <span style="color: ${getStatusColor(healthStatus.status.config)}">${healthStatus.status.config?.toUpperCase()}</span></div>
                                <div>Performance: <span style="color: ${getStatusColor(healthStatus.status.performance)}">${healthStatus.status.performance?.toUpperCase()}</span></div>
                                <div>Circuit Breaker: <span style="color: ${getStatusColor(healthStatus.status.circuitBreaker)}">${healthStatus.status.circuitBreaker?.toUpperCase()}</span></div>
                                <div>Storage: <span style="color: ${getStatusColor(healthStatus.status.storage)}">${healthStatus.status.storage?.toUpperCase()}</span></div>
                            </div>
                        </div>
                        
                        <div>
                            <h3 style="color: var(--primary); margin-bottom: 10px;">🖼️ IMAGE HEALING STATUS</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
                                <div>Success Rate: <span style="color: ${imageHealing.getDiagnostics().successRate !== 'N/A' ? '#00ffcc' : '#888'}">${imageHealing.getDiagnostics().successRate}</span></div>
                                <div>Fallback Rate: <span style="color: ${parseFloat(imageHealing.getDiagnostics().fallbackRate) > 20 ? '#ffaa00' : '#00ffcc'}">${imageHealing.getDiagnostics().fallbackRate}</span></div>
                                <div>Cache Hit Rate: <span style="color: ${imageHealing.getDiagnostics().cacheHitRate !== 'N/A' ? '#00ffcc' : '#888'}">${imageHealing.getDiagnostics().cacheHitRate}</span></div>
                                <div>Failed URLs: <span style="color: ${imageHealing.getDiagnostics().failedUrls > 0 ? '#ffaa00' : '#00ffcc'}">${imageHealing.getDiagnostics().failedUrls}</span></div>
                                <div>Cache Size: <span style="color: #00ffcc">${imageHealing.getDiagnostics().cacheSize}</span></div>
                                <div>Total Requests: <span style="color: #00ffcc">${imageHealing.getDiagnostics().metrics.totalRequests}</span></div>
                            </div>
                        </div>
                        
                        <div>
                            <h3 style="color: var(--primary); margin-bottom: 10px;">📊 SYSTEM METRICS</h3>
                            <div style="font-size: 0.9rem; line-height: 1.6;">
                                • API Calls: ${diagnostics.metrics.apiCalls}<br>
                                • API Failures: ${diagnostics.metrics.apiFailures}<br>
                                • Cache Hits: ${diagnostics.metrics.cacheHits}<br>
                                • Avg Response Time: ${Math.round(diagnostics.metrics.averageResponseTime)}ms<br>
                                • Cache Size: ${diagnostics.cacheSize} entries<br>
                                • Last Health Check: ${diagnostics.metrics.lastHealthCheck ? new Date(diagnostics.metrics.lastHealthCheck).toLocaleTimeString() : 'N/A'}
                            </div>
                        </div>
                        
                        <div>
                            <h3 style="color: var(--primary); margin-bottom: 10px;">🛡️ SELF-HEALING FEATURES</h3>
                            <div style="font-size: 0.9rem; line-height: 1.8;">
                                • Automatic API retry with exponential backoff<br>
                                • Circuit breaker pattern for API protection<br>
                                • Configuration validation and auto-repair<br>
                                • Network recovery and offline handling<br>
                                • Memory management and cleanup<br>
                                • Performance monitoring and optimization<br>
                                • Application state backup and recovery<br>
                                • Cross-tab data synchronization<br>
                                • Data integrity validation<br>
                                • Intelligent caching with health checks<br>
                                • Graceful degradation on failures<br>
                                • Real-time system health monitoring<br>
                                • <strong>Advanced image loading with fallbacks</strong><br>
                                • <strong>Service Worker offline capabilities</strong><br>
                                • <strong>Background sync and retry mechanisms</strong><br>
                                • <strong>Progressive web app functionality</strong>
                            </div>
                        </div>
                        
                        <div>
                            <h3 style="color: var(--primary); margin-bottom: 10px;">🌐 SERVICE WORKER STATUS</h3>
                            <div style="font-size: 0.9rem; line-height: 1.6;">
                                • Registration: ${navigator.serviceWorker ? (navigator.serviceWorker.controller ? 'ACTIVE' : 'REGISTERING') : 'NOT_SUPPORTED'}<br>
                                • Offline Support: ${navigator.serviceWorker ? 'ENABLED' : 'DISABLED'}<br>
                                • Background Sync: ${('serviceWorker' in navigator && 'sync' in window.ServiceWorkerRegistration.prototype) ? 'SUPPORTED' : 'NOT_SUPPORTED'}<br>
                                • Push Notifications: ${('serviceWorker' in navigator && 'PushManager' in window) ? 'SUPPORTED' : 'NOT_SUPPORTED'}
                            </div>
                        </div>
                        
                        <div>
                            <h3 style="color: var(--primary); margin-bottom: 10px;">⚙️ CONFIGURATION</h3>
                            <div style="font-size: 0.9rem; line-height: 1.6;">
                                • API Key: ${API_KEY !== 'YOUR_YOUTUBE_API_KEY' ? 'CONFIGURED' : 'DEMO MODE'}<br>
                                • Max Results: ${APP_CONFIG?.app_settings?.max_results || 50}<br>
                                • Videos Display: ${APP_CONFIG?.app_settings?.videos_to_display || 10}<br>
                                • Cache Duration: ${APP_CONFIG?.app_settings?.cache_duration_minutes || 30} minutes<br>
                                • Matrix Speed: ${APP_CONFIG?.ui_settings?.matrix_effect_speed || 35}ms<br>
                                • Autoplay Preview: ${APP_CONFIG?.ui_settings?.autoplay_preview !== false ? 'ENABLED' : 'DISABLED'}
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 25px;">
                        <button style="
                            background: linear-gradient(135deg, rgba(0, 30, 60, 0.8), rgba(0, 20, 40, 0.8));
                            border: 1px solid var(--border);
                            color: var(--light);
                            padding: 10px 20px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-family: 'Courier New', monospace;
                        " onclick="this.parentNode.parentNode.parentNode.remove()">
                            [ CLOSE TRANSMISSION ]
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(aboutModal);
            
            // Close on background click
            aboutModal.addEventListener('click', (e) => {
                if (e.target === aboutModal) {
                    aboutModal.remove();
                }
            });
        }
        
        // Show diagnostics modal
        function showDiagnostics() {
            const diagnostics = selfHealing.getDiagnostics();
            
            const diagModal = document.createElement('div');
            diagModal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.9);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                backdrop-filter: blur(5px);
            `;
            
            diagModal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, rgba(10, 10, 30, 0.95), rgba(5, 5, 20, 0.95));
                    border: 1px solid var(--border);
                    border-radius: 16px;
                    padding: 30px;
                    max-width: 800px;
                    max-height: 80vh;
                    overflow-y: auto;
                    color: var(--light);
                    font-family: 'Courier New', monospace;
                    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
                ">
                    <div style="text-align: center; margin-bottom: 25px;">
                        <h2 style="color: var(--primary); margin-bottom: 10px;">[ SYSTEM DIAGNOSTICS ]</h2>
                        <div style="color: var(--gray); font-size: 0.9rem;">Real-time system health monitoring</div>
                    </div>
                    
                    <div style="display: grid; gap: 20px;">
                        <div style="background: rgba(0, 20, 40, 0.3); padding: 15px; border-radius: 8px;">
                            <h3 style="color: var(--primary); margin-bottom: 10px;">📈 Performance Metrics</h3>
                            <pre style="font-size: 0.8rem; line-height: 1.4; margin: 0;">${JSON.stringify({
                                apiCalls: diagnostics.metrics.apiCalls,
                                apiFailures: diagnostics.metrics.apiFailures,
                                apiRetries: diagnostics.metrics.apiRetries,
                                circuitBreakerTrips: diagnostics.metrics.circuitBreakerTrips || 0,
                                storageRecoveries: diagnostics.metrics.storageRecoveries || 0,
                                successRate: diagnostics.metrics.apiCalls > 0 ? 
                                    ((diagnostics.metrics.apiCalls - diagnostics.metrics.apiFailures) / diagnostics.metrics.apiCalls * 100).toFixed(1) + '%' : 
                                    'N/A',
                                averageResponseTime: Math.round(diagnostics.metrics.averageResponseTime) + 'ms',
                                cacheHitRatio: (diagnostics.metrics.cacheHits + diagnostics.metrics.cacheMisses) > 0 ?
                                    (diagnostics.metrics.cacheHits / (diagnostics.metrics.cacheHits + diagnostics.metrics.cacheMisses) * 100).toFixed(1) + '%' :
                                    'N/A'
                            }, null, 2)}</pre>
                        </div>
                        
                        <div style="background: rgba(0, 20, 40, 0.3); padding: 15px; border-radius: 8px;">
                            <h3 style="color: var(--primary); margin-bottom: 10px;">🛡️ Circuit Breaker Status</h3>
                            <pre style="font-size: 0.8rem; line-height: 1.4; margin: 0;">${JSON.stringify({
                                state: diagnostics.circuitBreaker?.state || 'unknown',
                                failureCount: diagnostics.circuitBreaker?.failureCount || 0,
                                lastFailureTime: diagnostics.circuitBreaker?.lastFailureTime ? 
                                    new Date(diagnostics.circuitBreaker.lastFailureTime).toLocaleString() : 'N/A',
                                totalTrips: diagnostics.metrics.circuitBreakerTrips || 0
                            }, null, 2)}</pre>
                        </div>
                        
                        <div style="background: rgba(0, 20, 40, 0.3); padding: 15px; border-radius: 8px;">
                            <h3 style="color: var(--primary); margin-bottom: 10px;">💾 Storage Recovery</h3>
                            <pre style="font-size: 0.8rem; line-height: 1.4; margin: 0;">${JSON.stringify({
                                enabled: diagnostics.features?.storageRecovery || false,
                                available: diagnostics.storageManager?.available || false,
                                lastBackup: diagnostics.storageManager?.lastBackup ? 
                                    new Date(diagnostics.storageManager.lastBackup).toLocaleString() : 'N/A',
                                totalRecoveries: diagnostics.metrics.storageRecoveries || 0
                            }, null, 2)}</pre>
                        </div>
                        
                        <div style="background: rgba(0, 20, 40, 0.3); padding: 15px; border-radius: 8px;">
                            <h3 style="color: var(--primary); margin-bottom: 10px;">🔧 Configuration Status</h3>
                            <pre style="font-size: 0.8rem; line-height: 1.4; margin: 0;">${JSON.stringify({
                                apiKeyConfigured: API_KEY !== 'YOUR_YOUTUBE_API_KEY',
                                configValidation: diagnostics.healthStatus.config,
                                networkStatus: diagnostics.healthStatus.network,
                                apiStatus: diagnostics.healthStatus.api,
                                performanceStatus: diagnostics.healthStatus.performance,
                                circuitBreakerStatus: diagnostics.healthStatus.circuitBreaker,
                                storageStatus: diagnostics.healthStatus.storage,
                                featuresEnabled: {
                                    circuitBreaker: diagnostics.features?.circuitBreaker || false,
                                    storageRecovery: diagnostics.features?.storageRecovery || false,
                                    performanceMonitoring: diagnostics.features?.performanceMonitoring || false
                                }
                            }, null, 2)}</pre>
                        </div>
                        
                        <div style="background: rgba(0, 20, 40, 0.3); padding: 15px; border-radius: 8px;">
                            <h3 style="color: var(--primary); margin-bottom: 10px;">💾 System Resources</h3>
                            <pre style="font-size: 0.8rem; line-height: 1.4; margin: 0;">${JSON.stringify({
                                cacheEntries: diagnostics.cacheSize,
                                domNodes: document.querySelectorAll('*').length,
                                onlineStatus: diagnostics.online,
                                lastHealthCheck: diagnostics.metrics.lastHealthCheck ? 
                                    new Date(diagnostics.metrics.lastHealthCheck).toLocaleString() : 'Never',
                                memory: diagnostics.memory ? {
                                    used: Math.round(diagnostics.memory.usedJSHeapSize / 1024 / 1024) + ' MB',
                                    total: Math.round(diagnostics.memory.totalJSHeapSize / 1024 / 1024) + ' MB',
                                    limit: Math.round(diagnostics.memory.jsHeapSizeLimit / 1024 / 1024) + ' MB'
                                } : 'Not available'
                            }, null, 2)}</pre>
                        </div>
                        
                        <div style="background: rgba(0, 20, 40, 0.3); padding: 15px; border-radius: 8px;">
                            <h3 style="color: var(--primary); margin-bottom: 10px;">🕒 Self-Healing Actions</h3>
                            <div style="display: flex; gap: 10px; margin-top: 15px; flex-wrap: wrap;">
                                <button onclick="selfHealing.performHealthCheck(); this.textContent='Health Check Performed ✓'" style="
                                    background: linear-gradient(135deg, rgba(0, 100, 50, 0.8), rgba(0, 70, 35, 0.8));
                                    border: 1px solid #00aa55;
                                    color: white;
                                    padding: 8px 16px;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-family: 'Courier New', monospace;
                                    font-size: 0.8rem;
                                ">Perform Health Check</button>
                                
                                <button onclick="selfHealing.performMemoryCleanup(); this.textContent='Memory Cleaned ✓'" style="
                                    background: linear-gradient(135deg, rgba(0, 60, 100, 0.8), rgba(0, 40, 70, 0.8));
                                    border: 1px solid #0099cc;
                                    color: white;
                                    padding: 8px 16px;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-family: 'Courier New', monospace;
                                    font-size: 0.8rem;
                                ">Clean Memory</button>
                                
                                <button onclick="selfHealing.attemptRecovery(); this.textContent='Recovery Attempted ✓'" style="
                                    background: linear-gradient(135deg, rgba(100, 60, 0, 0.8), rgba(70, 40, 0, 0.8));
                                    border: 1px solid #cc9900;
                                    color: white;
                                    padding: 8px 16px;
                                    border-radius: 6px;
                                    cursor: pointer;
                                    font-family: 'Courier New', monospace;
                                    font-size: 0.8rem;
                                ">Attempt Recovery</button>
                            </div>
                        </div>
                    </div>
                    
                    <div style="text-align: center; margin-top: 25px;">
                        <button style="
                            background: linear-gradient(135deg, rgba(0, 30, 60, 0.8), rgba(0, 20, 40, 0.8));
                            border: 1px solid var(--border);
                            color: var(--light);
                            padding: 10px 20px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-family: 'Courier New', monospace;
                        " onclick="this.parentNode.parentNode.parentNode.remove()">
                            [ CLOSE DIAGNOSTICS ]
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(diagModal);
            
            // Close on background click
            diagModal.addEventListener('click', (e) => {
                if (e.target === diagModal) {
                    diagModal.remove();
                }
            });
        }
        
        // Initialize the app
        init();
    </script>
</body>
</html>